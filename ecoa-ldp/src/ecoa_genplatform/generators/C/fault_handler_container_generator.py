# -*- coding: utf-8 -*-
# Copyright (c) 2023 Dassault Aviation
# SPDX-License-Identifier: MIT

import os
from ecoa.utilities.logs import debug
from ..version_header_generator import generate_ldp_version_header_warning
from ..force_generation import file_need_generation


def generate_C_fault_handler_container(fault_handler_dir, current_PF, force_flag):
    """@TODO Function docstring"""
    c_filename = os.path.join(fault_handler_dir, current_PF.name + '_container.c')

    if not file_need_generation(c_filename,
                            force_flag,
                            "    A module container already exists for " + current_PF.name):
        return

    fd = open(c_filename, 'w')

    print(generate_ldp_version_header_warning(), file=fd)
    print("/* Fault Handler Container Skeleton for  %s */" % current_PF.name, file=fd)
    print("", file=fd)
    print("/* @file " + current_PF.name + "_container.c", file=fd)
    print(" * This is the Fault Handler Container for Fault Handler", file=fd)
    print(" * This file is generated by the ECOA tools and shall not be modified", file=fd)
    print(" */", file=fd)
    print("", file=fd)

    print("#include <assert.h>\n\
#include <apr_thread_proc.h>\n\
#include \"ldp_network.h\"\n\
#include \"{0}_container.h\"\n\
\n\
ECOA__return_status {0}_container__recovery_action (ldp_fault_handler_context* context, \n\
                                                          ECOA__recovery_action_type recovery_action, \n\
                                                          ECOA__asset_id asset_id,\n\
                                                          ECOA__asset_type asset_type){{\n".format(current_PF.name),
          file=fd)
    print("    if (asset_type != ECOA__asset_type_PROTECTION_DOMAIN) {\n\
        return ECOA__return_status_OPERATION_NOT_AVAILABLE;\n\
    }\n\
\n\
    ldp_Main_ctx* ctx=(ldp_Main_ctx*) context->platform_hook;\n\
    ECOA__log log;\n\
    int l_process_idx=-1;\n\
    for(int i=0; i<ctx->PD_number; ++i) {\n\
        if(ctx->pd_processes_array[i].proc.pid == asset_id) {\n\
            l_process_idx = i;\n\
            break;\n\
        }\n\
    }\n\
    if (l_process_idx == -1) {\n\
        return ECOA__return_status_INVALID_IDENTIFIER;\n\
    }\n\
    if (ctx->pd_processes_array[l_process_idx].pending_action == true) {\n\
        return ECOA__return_status_OPERATION_ALREADY_PENDING;\n\
    }\n\
\n\
    ECOA__return_status retval = ECOA__return_status_OK;\n\
    ctx->pd_processes_array[l_process_idx].pending_action = true;\n\
    switch(recovery_action){\n\
        case ECOA__recovery_action_type_SHUTDOWN:\n\
            {\n\
                // if process stopped no need to shutdown\n\
                if (ctx->pd_processes_array[l_process_idx].state == PROCESS_RUNNING) {\n\
                    log.current_size = snprintf ((char*)log.data, ECOA__LOG_MAXSIZE,\n\
                                                 \"[MAIN] Fault Handler RECOVERY: === Shutdown Protection Domain %s (pid=%d)\",\n\
                                                 ctx->pd_processes_array[l_process_idx].prog_names,\n\
                                                 ctx->pd_processes_array[l_process_idx].proc.pid);\n\
                    " + current_PF.name + "_container__log_info(context, log);\n\
                    write_msg(ctx->logger_PF, &ctx->interface_ctx_array[l_process_idx], LDP_ID_SHUTDOWN);\n\
                }\n\
            }\n\
            break;\n\
        case ECOA__recovery_action_type_COLD_RESTART:\n\
            {\n\
                if (ctx->pd_processes_array[l_process_idx].state == PROCESS_RUNNING) {\n\
                    write_msg(ctx->logger_PF, &ctx->interface_ctx_array[l_process_idx], LDP_ID_SHUTDOWN);\n\
                    write_msg(ctx->logger_PF, &ctx->interface_ctx_array[l_process_idx], LDP_ID_INIT_MOD);\n\
                }else{\n\
                    ldp_status_t ret;\n\
                    ret=apr_proc_create(&ctx->pd_processes_array[l_process_idx].proc,\n\
                                        ctx->pd_processes_array[l_process_idx].prog_names,\n\
                                        (const char**)ctx->pd_processes_array[l_process_idx].prog_argv,\n\
                                        NULL,\n\
                                        ctx->pd_processes_array[l_process_idx].procattr,\n\
                                        ctx->mem_pool);\n\
                    assert( ret== APR_SUCCESS);\n\
                    ctx->pd_processes_array[l_process_idx].state = PROCESS_RUNNING;\n\
                }\n\
                log.current_size = snprintf ((char*)log.data, ECOA__LOG_MAXSIZE,\n\
                                             \"[MAIN] Fault Handler RECOVERY: === Restarting process %s (pid=%d)\",\n\
                                             ctx->pd_processes_array[l_process_idx].prog_names,\n\
                                             ctx->pd_processes_array[l_process_idx].proc.pid);\n\
                " + current_PF.name + "_container__log_info(context, log);\n\
            }\n\
            break;\n\
        default:\n\
            retval = ECOA__return_status_OPERATION_NOT_AVAILABLE;\n\
            break;\n\
    }\n\
    ctx->pd_processes_array[l_process_idx].pending_action = false;\n\
    return retval;\n\
}", file=fd)

    print("/* Logging services API call specifications */\n\
void {0}_container__log_trace(ldp_fault_handler_context* context, const ECOA__log log){{\n\
   ldp_Main_ctx* ctx=(ldp_Main_ctx*) context->platform_hook;\n\
   ldp_log_PF_log(ECOA_LOG_TRACE_PF, \"TRACE\", ctx->logger_PF,  log.data);\n\
}}\n\
void {0}_container__log_debug(ldp_fault_handler_context* context, const ECOA__log log){{\n\
   ldp_Main_ctx* ctx=(ldp_Main_ctx*) context->platform_hook;\n\
   ldp_log_PF_log(ECOA_LOG_DEBUG_PF, \"DEBUG\", ctx->logger_PF, log.data);\n\
}}\n\
void {0}_container__log_info(ldp_fault_handler_context* context, const ECOA__log log){{\n\
   ldp_Main_ctx* ctx=(ldp_Main_ctx*) context->platform_hook;\n\
   ldp_log_PF_log(ECOA_LOG_INFO_PF, \"INFO\", ctx->logger_PF, log.data);\n\
}}\n\
void {0}_container__log_error(ldp_fault_handler_context* context, const ECOA__log log){{\n\
   ldp_Main_ctx* ctx=(ldp_Main_ctx*) context->platform_hook;\n\
   ldp_log_PF_log(ECOA_LOG_ERROR_PF, \"ERROR\", ctx->logger_PF, log.data);\n\
}}\n\
void {0}_container__log_warning(ldp_fault_handler_context* context, const ECOA__log log){{\n\
   ldp_Main_ctx* ctx=(ldp_Main_ctx*) context->platform_hook;\n\
   ldp_log_PF_log(ECOA_LOG_WARN_PF, \"WARNING\", ctx->logger_PF, log.data);\n\
}}".format(current_PF.name), file=fd)
    fd.close()


def generate_H_fault_handler_container(fault_handler_dir, current_PF, force_flag):
    """@TODO Function docstring"""
    h_filename = os.path.join(fault_handler_dir, current_PF.name + '_container.h')

    if not file_need_generation(h_filename,
                            force_flag,
                            "    A module container header already exists " + current_PF.name):
        return

    fd = open(h_filename, 'w')

    print(generate_ldp_version_header_warning(), file=fd)
    print("/* @file " + current_PF.name + "_container.h", file=fd)
    print(" * This is the Fault Handler Container header for Fault Handler", file=fd)
    print(" * This file is generated by the ECOA tools and shall not be modified", file=fd)
    print(" */", file=fd)
    print("", file=fd)
    print("#if !defined(_" + str.upper(current_PF.name) + "_CONTAINER_H)", file=fd)
    print("#define _" + str.upper(current_PF.name) + "_CONTAINER_H", file=fd)
    print("", file=fd)
    print("#if defined(__cplusplus)", file=fd)
    print("extern \"C\" {", file=fd)
    print("#endif", file=fd)
    print("", file=fd)

    print("#include \"ldp_time_manager.h\"\n\
#include \"ECOA.h\"\n\
#include \"{0}_user_context.h\"\n\
\n\
/* Incomplete definition of the technical (platform-dependent) part of the context\n\
 * (it will be defined privately by the container)\n\
 */\n\
struct {0}__platform_hook;\n\
\n\
\n\
/*\n\
 * Fault Handler Context structure declaration\n\
 */\n\
typedef struct ldp_fault_handler_context_t\n\
{{\n\
  /*\n\
   * Other container technical data will accessible through the pointer defined here\n\
   */\n\
  struct {0}__platform_hook *platform_hook;\n\
\n\
  /* the type {0}_user_context shall be defined by the user\n\
   * in the {0}_user_context.h file to carry the module\n\
   * implementation private data\n\
   */\n\
  {0}_user_context user;\n\
\n\
}} ldp_fault_handler_context;\n\
\n\
ECOA__return_status {0}_container__recovery_action (ldp_fault_handler_context* context, \n\
                                                          ECOA__recovery_action_type recovery_action, \n\
                                                          ECOA__asset_id asset_id,\n\
                                                          ECOA__asset_type asset_type);\n".format(current_PF.name),
          file=fd)

    print("/* Logging services API call specifications */\n\
void {0}_container__log_trace(ldp_fault_handler_context* context, const ECOA__log log);\n\
void {0}_container__log_debug(ldp_fault_handler_context* context, const ECOA__log log);\n\
void {0}_container__log_info(ldp_fault_handler_context* context, const ECOA__log log);\n\
void {0}_container__log_error(ldp_fault_handler_context* context, const ECOA__log log);\n\
void {0}_container__log_warning(ldp_fault_handler_context* context, const ECOA__log log);\n".format(current_PF.name),
          file=fd)

    print("#if defined(__cplusplus)", file=fd)
    print("} ", file=fd)
    print("#endif", file=fd)
    print("", file=fd)
    print("#endif  /* _" + str.upper(current_PF.name) + "_CONTAINER_H */", file=fd)

    fd.close()
