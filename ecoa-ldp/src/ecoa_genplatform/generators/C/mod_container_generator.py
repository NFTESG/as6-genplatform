# -*- coding: utf-8 -*-
# Copyright (c) 2023 Dassault Aviation
# SPDX-License-Identifier: MIT

import os
from .operation_generator import generate_header_fct, generate_broadcast_event_send_code,\
    generate_request_send_code, generate_response_send_code
from .properties_generator import property_get_function_generate
from ecoa.utilities.logs import debug
from ..fix_names import fix_C_data_type, fix_C_libname
from ..version_header_generator import generate_ldp_version_header_warning
from ..force_generation import file_need_generation


def generate_C_container(output_directory, mimpl, mtype,
                         libraries, comp_impl_name,
                         force_flag):
    """@TODO Function docstring"""
    c_filename = os.path.join(output_directory, mimpl.get_name() + '_container.c')

    if not file_need_generation(c_filename,
                            force_flag,
                            "    A module container already exists for " + mimpl.get_name()):
        return

    fd = open(c_filename, 'w')

    mname = mimpl.get_name()

    print(generate_ldp_version_header_warning(), file=fd)
    print("/* Module Container Implementation Skeleton for %s */" % mname, file=fd)
    print("", file=fd)
    print("/* @file " + mname + "_container.c", file=fd)
    print(" * This is the Module Container for Module " + mname, file=fd)
    print(" * This file is generated by the ECOA tools and shall not be modified", file=fd)
    print(" */", file=fd)
    print("", file=fd)
    print("#include <assert.h>", file=fd)
    print("#include \"route.h\"", file=fd)
    print("#include \"ldp_network.h\"", file=fd)
    print("#include \"ldp_time_manager.h\"", file=fd)
    print("#include \"ldp_VD.h\"", file=fd)
    print("#include \"ldp_ELI_udp.h\"", file=fd)

    print("#include \"ldp_mod_container_util.h\"", file=fd)
    print("#include \"" + mname + "_container.h\"", file=fd)
    print("#include \"component_" + comp_impl_name + "__properties.h\"", file=fd)
    print("", file=fd)
    for lib in libraries.values():
        print("#include \"" + fix_C_libname(lib.name) + ".h\"", file=fd)
        if lib.name != 'ECOA':
            print("#include \"" + fix_C_libname(lib.name) + "_serialization.h\"", file=fd)
        else:
            print("#include \"ECOA_simple_types_serialization.h\"", file=fd)

    print("", file=fd)

    for (opname, op) in mtype.get_operations().items():
        if op.get_type() == 'ES':
            # function declaration
            signature = "void " + mname + "_container__" + op.get_name() + "__send(" + mname \
                        + "__context* context"
            signature += generate_header_fct(op, with_input=True)
            signature += ")\n"
            signature += "{\n"

            # function content
            signature += generate_broadcast_event_send_code(op, op.op_output_index)

            signature += "}\n"
            print(signature, file=fd)

        elif op.get_type() == 'SRS':
            signature = "ECOA__return_status " + mname + "_container__" + op.get_name() \
                        + "__request_sync(" + mname + "__context* context"
            signature += generate_header_fct(op, with_input=True, with_output=True, output_mode=True)
            signature += ")\n"
            signature += "{\n"

            # function content
            signature += generate_request_send_code(op, op.op_output_index, True, op.RR_op_index)

            signature += "}\n"
            print(signature, file=fd)

        elif op.get_type() == 'ARS':
            signature = "ECOA__return_status " + mname + "_container__" + op.get_name() \
                        + "__request_async(" + mname + "__context* context"
            signature += ", ECOA__uint32* ID"
            signature += generate_header_fct(op, with_input=True)
            signature += ")\n"
            signature += "{\n"

            # function content
            signature += generate_request_send_code(op, op.op_output_index, False, op.RR_op_index)

            signature += "}\n"
            print(signature, file=fd)

        elif op.get_type() == 'RR':
            signature = "ECOA__return_status " + mname + "_container__" + op.get_name() \
                        + "__response_send(" + mname + "__context* context"
            signature += ", const ECOA__uint32 ID"
            signature += generate_header_fct(op, with_output=True, is_output_const=True,
                                             output_mode=False)
            signature += ")\n"
            signature += "{\n"

            # function content
            signature += generate_response_send_code(op, op.op_output_index, op.RR_op_index)

            signature += "}\n"
            print(signature, file=fd)

        elif op.get_type() == 'DW':
            data_type = op.get_params()[0].type

            print(
                "ECOA__return_status " + mname + "_container__" + op.get_name()
                + "__get_write_access(" + mname + "__context* context, " + mname + "_container__"
                + op.get_name() + "_handle* data_handle)",
                file=fd)
            print("{\n", file=fd)
            print("ldp_module_context* ctx = ((ldp_module_context*) context->platform_hook);\n", file=fd)
            print("ECOA__return_status ret = ldp_get_written_access(&ctx->VD_writter_managers["\
                        +str(op.module_VD_op_index)+"], (ldp_VD_handle*) data_handle);\n", file=fd)
            print("if (ret != ECOA__return_status_OK){ \n\
   ldp_send_fault_error_to_father(ctx->component_ctx, ctx->mod_id, ECOA__asset_type_COMPONENT,\n\
                                    ECOA__error_type_RESOURCE_NOT_AVAILABLE, 12);\n}\n", file=fd)
            print("    return ret;\n}\n", file=fd)

            print(
                "ECOA__return_status " + mname + "_container__" + op.get_name()
                + "__cancel_write_access(" + mname + "__context* context, " + mname + "_container__"
                + op.get_name() + "_handle* data_handle)",
                file=fd)
            print("{\n", file=fd)
            print("ldp_module_context* ctx = ((ldp_module_context*) context->platform_hook);\n", file=fd)
            print("ECOA__return_status ret = ldp_cancel_written_access(&ctx->VD_writter_managers["\
                    +str(op.module_VD_op_index)+"], (ldp_VD_handle*) data_handle);\n", file=fd)
            print("if (ret != ECOA__return_status_OK){ \n\
   ldp_send_fault_error_to_father(ctx->component_ctx, ctx->mod_id, ECOA__asset_type_COMPONENT,\n\
                                    ECOA__error_type_RESOURCE_NOT_AVAILABLE, 13);\n}\n", file=fd)
            print("return ret;\n", file=fd)
            print("}\n", file=fd)

            print(
                "ECOA__return_status " + mname + "_container__" + op.get_name()
                + "__publish_write_access(" + mname + "__context* context, " + mname
                + "_container__" + op.get_name() + "_handle* data_handle)",
                file=fd)
            print("{\n  ", file=fd)
            print("ldp_module_context* ctx = ((ldp_module_context*) context->platform_hook);\n", file=fd)
            print("ECOA__return_status ret = ldp_publish_written_access(ctx, &ctx->VD_writter_managers["\
                    +str(op.module_VD_op_index)+"], (ldp_VD_handle*) data_handle);\n", file=fd)
            print("if (ret != ECOA__return_status_OK){ \n\
   ldp_send_fault_error_to_father(ctx->component_ctx, ctx->mod_id, ECOA__asset_type_COMPONENT,\n\
                                    ECOA__error_type_RESOURCE_NOT_AVAILABLE, 14);\n}\n", file=fd)
            print("return ret;\n", file=fd)
            print("}\n", file=fd)

        elif op.get_type() == 'DR' or op.get_type() == 'DRN':
            print(
                "ECOA__return_status " + mname + "_container__" + op.get_name()
                + "__get_read_access(" + mname + "__context* context, " + mname + "_container__"
                + op.get_name() + "_handle* data_handle)",
                file=fd)
            print("{\n", file=fd)
            print("ldp_module_context* ctx = ((ldp_module_context*) context->platform_hook);\n", file=fd)
            print("ECOA__return_status ret = ldp_get_read_access(&ctx->VD_reader_managers[" \
                  +str(op.module_VD_op_index)+"], (ldp_VD_handle*) data_handle);\n", file=fd)
            print("if (ret != ECOA__return_status_OK){ \n\
   ldp_send_fault_error_to_father(ctx->component_ctx, ctx->mod_id, ECOA__asset_type_COMPONENT,\n\
                                    ECOA__error_type_RESOURCE_NOT_AVAILABLE, 15);\n}\n", file=fd)
            print("return ret;\n}\n", file=fd)
            print(
                "ECOA__return_status " + mname + "_container__" + op.get_name()
                + "__release_read_access(" + mname + "__context* context, " + mname
                + "_container__" + op.get_name() + "_handle* data_handle)",
                file=fd)
            print("{\n", file=fd)
            print("ldp_module_context* ctx = ((ldp_module_context*) context->platform_hook);\n", file=fd)
            print("ECOA__return_status ret = ldp_release_read_access(&ctx->VD_reader_managers["\
                +str(op.module_VD_op_index)+"], (ldp_VD_handle*) data_handle);\n", file=fd)
            print("if (ret != ECOA__return_status_OK){ \n\
   ldp_send_fault_error_to_father(ctx->component_ctx, ctx->mod_id, ECOA__asset_type_COMPONENT,\n\
                                    ECOA__error_type_RESOURCE_NOT_AVAILABLE, 16);\n}\n", file=fd)
            print("return ret;\n", file=fd)
            print("}\n", file=fd)
        else:
            # nothing to do
            pass

    print(generate_properties_functions(mtype, mname), file=fd)
    print(generate_pinfo_functions(mtype, mname), file=fd)

    text = "/* Logging services API call specifications */\n"
    text += "void " + mname + "_container__log_trace(" + mname \
            + "__context* context, const ECOA__log log){\n"
    text += "   ldp_module_context* ctx=(ldp_module_context*) context->platform_hook;\n"
    text += "   ldp__timestamp timestamp;\n"
    text += "   ldp_get_ecoa_utc_time(&timestamp);\n"
    text += "   ldp_log_log(ECOA_LOG_TRACE, \"TRACE\", ctx->logger,  log.data, &timestamp);\n"

    text += "}\n"

    text += "void " + mname + "_container__log_debug(" + mname \
            + "__context* context, const ECOA__log log){\n"
    text += "   ldp_module_context* ctx=(ldp_module_context*) context->platform_hook;\n"
    text += "   ldp__timestamp timestamp;\n"
    text += "   ldp_get_ecoa_utc_time(&timestamp);\n"
    text += "   ldp_log_log(ECOA_LOG_DEBUG, \"DEBUG\", ctx->logger, log.data, &timestamp);\n"

    text += "}\n"

    text += "void " + mname + "_container__log_info(" + mname \
            + "__context* context, const ECOA__log log){\n"
    text += "   ldp_module_context* ctx=(ldp_module_context*) context->platform_hook;\n"
    text += "   ldp__timestamp timestamp;\n"
    text += "   ldp_get_ecoa_utc_time(&timestamp);\n"
    text += "   ldp_log_log(ECOA_LOG_INFO, \"INFO\", ctx->logger, log.data, &timestamp);\n"
    text += "}\n"

    text += "void " + mname + "_container__log_warning(" + mname \
            + "__context* context, const ECOA__log log){\n"
    text += "   ldp_module_context* ctx=(ldp_module_context*) context->platform_hook;\n"
    text += "   ldp__timestamp timestamp;\n"
    text += "   ldp_get_ecoa_utc_time(&timestamp);\n"
    text += "   ldp_log_log(ECOA_LOG_WARN, \"WARNING\", ctx->logger, log.data, &timestamp);\n"
    text += "}\n"
    text += "void " + mname + "_container__raise_error(" + mname \
            + "__context* context, const ECOA__log log, const ECOA__error_code error_code){\n"
    text += "   ldp_module_context* ctx=(ldp_module_context*) context->platform_hook;\n"
    text += "   ldp_send_fault_error_to_father(ctx->component_ctx, ctx->mod_id, ECOA__asset_type_COMPONENT, ECOA__error_type_ERROR, 1);\n"
    text += "   ldp__timestamp timestamp;\n"
    text += "   ldp_get_ecoa_utc_time(&timestamp);\n"
    text += "   ldp_log_log(ECOA_LOG_ERROR, \"ERROR\", ctx->logger, log.data, &timestamp);\n"
    text += "}\n"
    text += "void " + mname + "_container__raise_fatal_error(" + mname \
            + "__context* context, const ECOA__log log, const ECOA__error_code error_code){\n"
    text += "   ldp_module_context* ctx=(ldp_module_context*) context->platform_hook;\n"
    text += "   find_dest_mod_by_comp_and_send(ctx->component_ctx, ctx->component_name, LDP_ID_SHUTDOWN_life);\n"
    text += "   ldp_send_fault_error_to_father(ctx->component_ctx, ctx->mod_id, ECOA__asset_type_COMPONENT, ECOA__error_type_FATAL_ERROR, 1);\n"
    text += "   ldp__timestamp timestamp;\n"
    text += "   ldp_get_ecoa_utc_time(&timestamp);\n"
    text += "   ldp_log_log(ECOA_LOG_FATAL, \"FATAL\", ctx->logger, log.data, &timestamp);\n"
    text += "}\n"
    print(text, file=fd)

    print("/* Recovery action service API call specification if the module is a Fault Handler */",
          file=fd)
    if mtype.is_fault_handler():
        print("/* Fault Handling API */", file=fd)
        print("", file=fd)
        print("void " + mname + "_container__recovery_action(", file=fd)
        print("    " + mname + "__context* context,", file=fd)
        print(
            "    ECOA__recovery_action_type recovery_action, ECOA__asset_id asset_id, "
            "ECOA__asset_type asset_type)",
            file=fd)
        print("{\n  /* @TODO TODO - To be implemented */\n}\n", file=fd)
    print("", file=fd)

    text = "/* Time Services API call specifications */\n"
    text += "void " + mname + "_container__get_relative_local_time(" + mname \
            + "__context* context, ECOA__hr_time *relative_local_time){\n"
    text += "    ldp_get_ecoa_relative_time(NULL, (ldp__timestamp*) relative_local_time);\n"
    text += "    UNUSED(context);\n"
    text += "}\n"

    text += "ECOA__return_status " + mname + "_container__get_UTC_time(" + mname \
            + "__context* context, ECOA__global_time *utc_time){\n"
    text += "    ldp_get_ecoa_utc_time((ldp__timestamp *) utc_time);\n"
    text += "    UNUSED(context);\n"
    text += "    return ECOA__return_status_OK;\n"
    text += "}\n\n"

    text += "ECOA__return_status " + mname + "_container__get_absolute_system_time(" \
            + mname + "__context* context, ECOA__global_time *absolute_system_time){\n"
    text += "    ldp_get_ecoa_absolute_time((ldp__timestamp *) absolute_system_time);\n"
    text += "    UNUSED(context);\n"
    text += "    return ECOA__return_status_OK;\n"
    text += "}\n\n"
    print(text, file=fd)

    print(
        "void " + mname + "_container__get_relative_local_time_resolution(" + mname
        + "__context* context, ECOA__duration *relative_local_time_resolution)",
        file=fd)
    print(
        "{\n  ldp_get_ecoa_relative_timeres((ldp__timestamp *)"
        "relative_local_time_resolution);\n",
        file=fd)
    print("UNUSED(context);\n}\n", file=fd)
    print(
        "void " + mname + "_container__get_UTC_time_resolution(" + mname
        + "__context* context, ECOA__duration *utc_time_resolution)",
        file=fd)
    print("{\n  ldp_get_ecoa_utc_timeres((ldp__timestamp *)utc_time_resolution);\n",file=fd)
    print("UNUSED(context);\n}\n", file=fd)
    print(
        "void " + mname + "_container__get_absolute_system_time_resolution(" + mname
        + "__context* context, ECOA__duration *absolute_system_time_resolution)",
        file=fd)
    print(
        "{\n  ldp_get_ecoa_absolute_timeres((ldp__timestamp *)"
        "absolute_system_time_resolution);\n",
        file=fd)
    print("UNUSED(context);\n}\n", file=fd)
    print("", file=fd)

    fd.close()


def generate_properties_functions(mtype, mname):
    """@TODO Function docstring"""
    text = "/* Properties API */\n"
    for (_, prop) in mtype.get_properties().items():
        text += property_get_function_generate(prop, mtype, mname)
    text += "\n"
    return text


def generate_pinfo_functions(mtype, mname):
    """@TODO Function docstring"""
    text = "/* PINFO API */\n"
    for index, pinfo_name in enumerate(mtype.public_pinfo + mtype.private_pinfo):
        text += "ECOA__return_status " + mname + "_container__seek_" + pinfo_name
        text += "(" + mname + "__context* context, ECOA__int32 offset, " \
                              "ECOA__seek_whence_type whence, ECOA__uint32 *new_position){\n"
        text += "   ldp_module_context* ctx=(ldp_module_context*) context->platform_hook;\n"

        text += "   return ldp_pinfo_seek(&ctx->pinfo_manager.pinfo_array[" + str(
            index) + "], offset, new_position, whence);\n"

        text += "}\n"

        text += "ECOA__return_status " + mname + "_container__read_" + pinfo_name
        text += "(" + mname + "__context* context, ECOA__byte *memory_address, " \
                              "ECOA__uint32 in_size, ECOA__uint32 *out_size){\n"
        text += "    ldp_module_context* ctx=(ldp_module_context*) context->platform_hook;\n"
        text += "    return ldp_pinfo_read(&ctx->pinfo_manager.pinfo_array[" + str(
            index) + "], memory_address ,in_size, out_size);\n"
        text += "}\n"
    return text


def generate_H_container(output_directory, mimpl, mtype, libraries,
                         force_flag):
    """@TODO Function docstring"""
    h_filename = os.path.join(output_directory, mimpl.get_name() + '_container.h')

    if not file_need_generation(h_filename,
                            force_flag,
                            "    A module container header already exists " + mimpl.get_name()):
        return

    fd = open(h_filename, 'w')

    mname = mimpl.get_name()

    print(generate_ldp_version_header_warning(), file=fd)
    print("/* @file " + mname + "_container.h", file=fd)
    print(" * This is the Module Container header for Module " + mname, file=fd)
    print(" * This file is generated by the ECOA tools and shall not be modified", file=fd)
    print(" */", file=fd)
    print("", file=fd)
    print("#if !defined(_" + str.upper(mname) + "_CONTAINER_H)", file=fd)
    print("#define _" + str.upper(mname) + "_CONTAINER_H", file=fd)
    print("", file=fd)
    print("#if defined(__cplusplus)", file=fd)
    print("extern \"C\" {", file=fd)
    print("#endif", file=fd)
    print("", file=fd)
    print("#include \"ECOA.h\"", file=fd)
    for lib in libraries.keys():
        print("#include \"" + fix_C_libname(lib) + ".h\"", file=fd)
    if not mimpl.is_binary_module():
        print("#include \"" + mname + "_user_context.h\"", file=fd)
    print("", file=fd)
    print("#define ECOA_VERSIONED_DATA_HANDLE_PRIVATE_SIZE 32", file=fd)
    print("", file=fd)
    print("/* Incomplete definition of the technical (platform-dependent) part of the context",
          file=fd)
    print(" * (it will be defined privately by the container)", file=fd)
    print(" */", file=fd)
    print("struct " + mname + "__platform_hook;", file=fd)
    print("\n", file=fd)
    print("/* Module Context structure declaration */", file=fd)
    print("typedef struct", file=fd)
    print("{", file=fd)
    print("  /*", file=fd)
    print("   * Other container technical data will accessible through the pointer defined here",
          file=fd)
    print("   */", file=fd)
    print("  struct " + mname + "__platform_hook *platform_hook;", file=fd)
    print("", file=fd)
    if mtype.has_user_context():
        print("  /* the type " + mname + "_user_context shall be defined by the user", file=fd)
        print("   * in the " + mname + "_user_context.h file to carry the module", file=fd)
        print("   * implementation private data", file=fd)
        print("   */", file=fd)
        if mimpl.is_binary_module():
            print("  ECOA__byte user["+mimpl.binary_desc.userContextSize+"];",file=fd)
        else:
            print("  " + mname + "_user_context user;", file=fd)
        print("", file=fd)

    if mtype.has_warm_start_context():
        print("  /*", file=fd)
        print("   * When the optional warm start context is used, the type", file=fd)
        print("   * "+mname+"_warm_start_context shall be defined by the", file=fd)
        print("   * user in the "+mname+"_user_context.h file to carry the module", file=fd)
        print("   * implementation warm start private data and the attribute", file=fd)
        print("   * "+mname+"_warm_start_context user shall be declared as follows:", file=fd)
        print("   */", file=fd)
        if mimpl.is_binary_module():
            print("  ECOA__byte warm_start["+mimpl.binary_desc.warmStartContextSize+"];",file=fd)
        else:
            print("  " + mname + "_warm_start_context warm_start;", file=fd)
    print("} " + mname + "__context;", file=fd)
    print("", file=fd)

    for (_, op) in mtype.get_operations().items():
        if op.get_type() == 'ES':

            signature = "void " + mname + "_container__" + op.get_name() + "__send(" + mname \
                        + "__context* context"
            signature += generate_header_fct(op, with_input=True)
            signature += ");"
            print(signature, file=fd)
            print("", file=fd)
        elif op.get_type() == 'SRS':
            signature = "ECOA__return_status " + mname + "_container__" + op.get_name() \
                        + "__request_sync(" + mname + "__context* context"
            signature += generate_header_fct(op, with_input=True, with_output=True, output_mode=True)
            signature += ");"
            print(signature, file=fd)
            print("", file=fd)
        elif op.get_type() == 'ARS':
            signature = "ECOA__return_status " + mname + "_container__" + op.get_name() \
                        + "__request_async(" + mname + "__context* context"
            signature += ", ECOA__uint32* ID"
            signature += generate_header_fct(op, with_input=True)
            signature += ");"
            print(signature, file=fd)
            print("", file=fd)
        elif op.get_type() == 'RR':
            signature = "ECOA__return_status " + mname + "_container__" + op.get_name() \
                        + "__response_send(" + mname + "__context* context"
            signature += ", const ECOA__uint32 ID"
            signature += generate_header_fct(op, with_output=True, is_output_const=True, output_mode=False)
            signature += ");"
            print(signature, file=fd)
            print("", file=fd)
        elif op.get_type() == 'DW':
            data_type = fix_C_data_type(op.get_params()[0].type)
            print("/*", file=fd)
            print(" * The following is the data handle structure associated to the data operation",
                  file=fd)
            print(" * called " + op.get_name() + " of data-type " + data_type, file=fd)
            print(" */", file=fd)
            print("typedef struct {", file=fd)
            for param in op.get_params():
                if param.direction == 'input':
                    print(
                        "   " + data_type + "* data;   /* pointer to the local copy of the data */",
                        file=fd)
            print(
                "   ECOA__uint32 stamp; /* counter of the last update of that version of "
                "the data */",
                file=fd)
            print(
                "   ECOA__byte platform_hook[ECOA_VERSIONED_DATA_HANDLE_PRIVATE_SIZE]; "
                "/* technical info associated with the data (opaque for the user, reserved "
                "for the infrastructure) */",
                file=fd)
            print("} " + mname + "_container__" + op.get_name() + "_handle;", file=fd)
            print("", file=fd)
            print(
                "ECOA__return_status " + mname + "_container__" + op.get_name()
                + "__get_write_access(" + mname + "__context* context, " + mname
                + "_container__" + op.get_name() + "_handle* data_handle);",
                file=fd)
            print(
                "ECOA__return_status " + mname + "_container__" + op.get_name()
                + "__cancel_write_access(" + mname + "__context* context, " + mname + "_container__"
                + op.get_name() + "_handle* data_handle);",
                file=fd)
            print(
                "ECOA__return_status " + mname + "_container__" + op.get_name()
                + "__publish_write_access(" + mname + "__context* context, " + mname
                + "_container__" + op.get_name() + "_handle* data_handle);",
                file=fd)
            print("", file=fd)
        elif op.get_type() == 'DR' or op.get_type() == 'DRN':
            data_type = fix_C_data_type(op.get_params()[0].type)
            print("/*", file=fd)
            print(" * The following is the data handle structure associated to the data operation",
                  file=fd)
            print(" * called " + op.get_name() + " of data-type " + data_type, file=fd)
            print(" */", file=fd)
            print("typedef struct {", file=fd)
            for param in op.get_params():
                if param.direction == 'input':
                    print(
                        "   " + data_type + "* data;   /* pointer to the local copy of the data */",
                        file=fd)
            print(
                "   ECOA__uint32 stamp; /* counter of the last update of that version of the "
                "data */",
                file=fd)
            print(
                "   ECOA__byte platform_hook[ECOA_VERSIONED_DATA_HANDLE_PRIVATE_SIZE]; "
                "/* technical "
                "info associated with the data (opaque for the user, reserved for the "
                "infrastructure) */",
                file=fd)
            print("} " + mname + "_container__" + op.get_name() + "_handle;", file=fd)
            print("", file=fd)
            print(
                "ECOA__return_status " + mname + "_container__" + op.get_name()
                + "__get_read_access(" + mname + "__context* context, " + mname + "_container__"
                + op.get_name() + "_handle* data_handle);",
                file=fd)
            print(
                "ECOA__return_status " + mname + "_container__" + op.get_name()
                + "__release_read_access(" + mname + "__context* context, " + mname
                + "_container__" + op.get_name() + "_handle* data_handle);",
                file=fd)
            print("", file=fd)

    print("/* Properties API */", file=fd)
    for (_, prop) in mtype.get_properties().items():
        print(
            "void " + mname + "_container__get_" + prop.get_name() + "_value("
            + mname + "__context* context, " + fix_C_data_type(prop.get_type()) + "* value);",
            file=fd)
    print("", file=fd)

    print("/* PINFO API */", file=fd)
    for pinfo_name in mtype.private_pinfo + mtype.public_pinfo:
        print(
            "ECOA__return_status " + mname + "_container__seek_" + pinfo_name + "("
            + mname + "__context* context, ECOA__int32 offset,ECOA__seek_whence_type whence, "
                      "ECOA__uint32 *new_position);",
            file=fd)
        print(
            "ECOA__return_status " + mname + "_container__read_" + pinfo_name + "("
            + mname + "__context* context, ECOA__byte *memory_address, ECOA__uint32 in_size, "
                      "ECOA__uint32 *out_size);",
            file=fd)
    print("", file=fd)

    print("/* Logging services API call specifications */", file=fd)
    print(
        "void " + mname + "_container__log_trace(" + mname
        + "__context* context, const ECOA__log log);",
        file=fd)
    print(
        "void " + mname + "_container__log_debug(" + mname
        + "__context* context, const ECOA__log log);",
        file=fd)
    print(
        "void " + mname + "_container__log_info(" + mname
        + "__context* context, const ECOA__log log);",
        file=fd)
    print(
        "void " + mname + "_container__log_warning(" + mname
        + "__context* context, const ECOA__log log);",
        file=fd)
    print(
        "void " + mname + "_container__raise_error(" + mname
        + "__context* context, const ECOA__log log,const ECOA__error_code error_code);",
        file=fd)
    print(
        "void " + mname + "_container__raise_fatal_error(" + mname
        + "__context* context, const ECOA__log log, const ECOA__error_code error_code);",
        file=fd)
    print("", file=fd)

    print("/* Recovery action service API call specification if the module is a Fault Handler */",
          file=fd)
    if mtype.is_fault_handler():
        print("/* Fault Handling API */", file=fd)
        print("", file=fd)
        print("void " + mname + "_container__recovery_action(", file=fd)
        print("    " + mname + "__context* context,", file=fd)
        print(
            "    ECOA__recovery_action_type recovery_action, ECOA__asset_id asset_id,"
            " ECOA__asset_type asset_type);",
            file=fd)
    print("", file=fd)

    print("/* Time Services API call specifications */", file=fd)
    print(
        "void " + mname + "_container__get_relative_local_time(" + mname
        + "__context* context, ECOA__hr_time *relative_local_time);",
        file=fd)
    print(
        "ECOA__return_status " + mname + "_container__get_UTC_time(" + mname
        + "__context* context, ECOA__global_time *utc_time);",
        file=fd)
    print(
        "ECOA__return_status " + mname + "_container__get_absolute_system_time("
        + mname + "__context* context, ECOA__global_time *absolute_system_time);",
        file=fd)
    print(
        "void " + mname + "_container__get_relative_local_time_resolution("
        + mname + "__context* context, ECOA__duration *relative_local_time_resolution);",
        file=fd)
    print(
        "void " + mname + "_container__get_UTC_time_resolution(" + mname
        + "__context* context, ECOA__duration *utc_time_resolution);",
        file=fd)
    print(
        "void " + mname + "_container__get_absolute_system_time_resolution("
        + mname + "__context* context, ECOA__duration *absolute_system_time_resolution);",
        file=fd)
    print("", file=fd)

    print("#if defined(__cplusplus)", file=fd)
    print("} ", file=fd)
    print("#endif", file=fd)
    print("", file=fd)
    print("#endif  /* _" + str.upper(mname) + "_CONTAINER_H */", file=fd)

    fd.close()
