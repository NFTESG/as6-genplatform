# -*- coding: utf-8 -*-
# Copyright (c) 2023 Dassault Aviation
# SPDX-License-Identifier: MIT

import os
from .operation_generator import generate_param_fct_call, generate_header_fct
from .utilities import expand_data_type
from ..force_generation import file_need_generation

spaces = "	"


def generate_C_module_test(directory, mimpl, mtype, libraries,
                           force_flag):
    """@TODO Function docstring"""
    c_filename = os.path.join(directory, mimpl.get_name() + '_test.c')

    if file_need_generation(c_filename,
                            force_flag,
                            "    A module test already exists for " + mimpl.get_name()):

        fd = open(c_filename, 'w')

        mname = mimpl.get_name()
        data_already_declared = []

        print("/* Generated by LDP */", file=fd)
        print("/* Tests of the Module Implementation %s */" % mname, file=fd)
        print("", file=fd)
        print("#include \"ECOA.h\"", file=fd)
        print("#include \"" + mname + ".h\"", file=fd)
        print("", file=fd)
        for lib in libraries:
            print("#include \"" + lib + ".h\"", file=fd)
        print("", file=fd)
        print("int main(int argc, char *argv[])", file=fd)
        print("{", file=fd)
        print(spaces + mname + "__context context;", file=fd)
        print(spaces + "ECOA__uint32 ID;", file=fd)
        print(spaces + mname + "__INITIALIZE__received(&context);", file=fd)
        print(spaces + mname + "__START__received(&context);", file=fd)
        print(spaces + mname + "__STOP__received(&context);", file=fd)
        print(spaces + mname + "__SHUTDOWN__received(&context);", file=fd)
        print("", file=fd)

        for (opname, operation) in mtype.get_operations().items():
            if operation.get_type() == 'ER':

                for param in operation.get_params():
                    param_type = expand_data_type(param.type)
                    if param.name not in data_already_declared:
                        print(spaces + param_type + ' ' + param.name + ";", file=fd)
                        data_already_declared.append(param.name)

                signature = spaces + mname + "__" + operation.get_name() + "__received(&context"
                for param in operation.get_params():
                    signature += ", " + param.name
                signature += ");"
                print(signature, file=fd)
                print("", file=fd)
            elif operation.get_type() == 'RR':
                for param in operation.get_params():
                    param_type = expand_data_type(param.type)
                    if param.name not in data_already_declared:
                        print(spaces + param_type + ' ' + param.name + ";", file=fd)
                        data_already_declared.append(param.name)

                signature = spaces + mname + "__" + operation.get_name() + "__request_received(&context"
                signature += ", ID"

                signature += generate_param_fct_call(operation, with_input=True, with_output=False)
                signature += ");"
                print(signature, file=fd)
                print("", file=fd)

        if mtype.is_fault_handler():
            print("/* Fault Handling API */", file=fd)
            print("", file=fd)
            print(spaces + "ECOA__error_id error_id;", file=fd)
            print(spaces + mname + "__error_notification(&context, error_id)", file=fd)

        print("    return 0;", file=fd)
        print("}", file=fd)
        fd.close()


def generate_C_test_makefile(directory, mimpl, force_flag):
    """@TODO Function docstring"""
    c_filename = os.path.join(directory, mimpl.get_name() + '_test.mak')

    if file_need_generation(c_filename,
                            force_flag,
                            "    A module test makefile already exists for " + mimpl.get_name()):

        fd = open(c_filename, 'w')
        mname = mimpl.get_name()

        print("all: test", file=fd)
        print("", file=fd)
        print("test:", file=fd)
        print(
            "\tgcc -g -Wall -o test ../src/" + mname + ".c " + mname + "_test_container.c "
            + mname + "_test.c -I ../inc -I ../inc-gen/ -I ../../../../0-Types/inc-gen/ "
                      "-DECOA_64BIT_SUPPORT",
            file=fd)
        print("", file=fd)
        print("clean:", file=fd)
        print("\trm -f test", file=fd)
        fd.close()


def generate_C_test_container(directory, mimpl, mtype, libraries,
                              force_flag):
    """@TODO Function docstring"""
    default_generated_comment = "  /* @TODO TODO - To be implemented */"

    c_filename = os.path.join(directory, mimpl.get_name() + '_test_container.c')

    if file_need_generation(c_filename,
                            force_flag,
                            "    A module test container already exists for " + mimpl.get_name()):

        fd = open(c_filename, 'w')

        mname = mimpl.get_name()

        print("/* Module Test Container Implementation Skeleton for %s */" % (mname), file=fd)
        print("", file=fd)
        print("/* @file " + mname + "_test_container.c", file=fd)
        print(" * This is the Module Test Container for Module " + mname, file=fd)
        print(" * This file is generated by the ECOA tools and shall not be modified", file=fd)
        print(" */", file=fd)
        print("", file=fd)
        print("/* Generated by LDP */", file=fd)
        print("", file=fd)
        print("#include <stdlib.h>", file=fd)
        print("", file=fd)
        print("#include \"ECOA.h\"", file=fd)
        print("#include \"" + mname + "_container.h\"", file=fd)
        print("", file=fd)
        for lib in libraries:
            print("#include \"" + lib + ".h\"", file=fd)
        print("", file=fd)

        for (opname, op) in mtype.get_operations().items():
            if op.get_type() == 'ES':

                signature = "void " + mname + "_container__" + op.get_name() + "__send(" + mname \
                            + "__context* context"
                signature += generate_header_fct(op, with_input=True)
                signature += ")\n"
                signature += "{\n"
                signature += default_generated_comment+"\n"
                signature += "}"
                print(signature, file=fd)
                print("", file=fd)
            elif op.get_type() == 'SRS':
                signature = "ECOA__return_status " + mname + "_container__" + op.get_name() \
                            + "__request_sync(" + mname + "__context* context"
                signature += generate_header_fct(op, with_input=True, with_output=True)
                signature += ")\n"
                signature += "{\n"
                signature += default_generated_comment+"\n"
                signature += "  ECOA__return_status return_status = ECOA__return_status_OK;\n"
                signature += "  return return_status;\n"
                signature += "}"
                print(signature, file=fd)
                print("", file=fd)
            elif op.get_type() == 'ARS':
                signature = "ECOA__return_status " + mname + "_container__" + op.get_name() \
                            + "__request_async(" + mname + "__context* context"
                signature += ", ECOA__uint32* ID"
                signature += generate_header_fct(op, with_input=True)
                signature += ")\n"
                signature += "{\n"
                signature += default_generated_comment+"\n"
                signature += "  ECOA__return_status return_status = ECOA__return_status_OK;"
                signature += "  return return_status;"
                signature += "}"
                print(signature, file=fd)
                print("", file=fd)
            elif op.get_type() == 'RR':
                signature = "ECOA__return_status " + mname + "_container__" + op.get_name() \
                            + "__response_send(" + mname + "__context* context"
                signature += ", const ECOA__uint32 ID"
                signature += generate_header_fct(op, with_output=True, output_mode=False)
                signature += ")\n"
                signature += "{\n"
                signature += default_generated_comment+"\n"
                signature += "  ECOA__return_status return_status = ECOA__return_status_OK;"
                signature += "  return return_status;"
                signature += "}"
                print(signature, file=fd)
                print("", file=fd)
            elif op.get_type() == 'DW':
                data_type = op.get_params()[0].type
                data_type = expand_data_type(data_type)

                print(
                    "ECOA__return_status " + mname + "_container__" + op.get_name()
                    + "__get_write_access(" + mname + "__context* context, " + mname
                    + "_container__" + op.get_name() + "_handle* data_handle)",
                    file=fd)
                print("{\n" + default_generated_comment, file=fd)
                print("  ECOA__return_status return_status = ECOA__return_status_OK;", file=fd)
                print("  data_handle->data = malloc(sizeof(" + data_type + "));", file=fd)
                print("  return return_status;", file=fd)
                print("}\n", file=fd)
                print(
                    "ECOA__return_status " + mname + "_container__" + op.get_name()
                    + "__cancel_write_access(" + mname + "__context* context, " + mname
                    + "_container__" + op.get_name() + "_handle* data_handle)",
                    file=fd)
                print("{\n" + default_generated_comment, file=fd)
                print("  ECOA__return_status return_status = ECOA__return_status_OK;", file=fd)
                print("  return return_status;", file=fd)
                print("}\n", file=fd)
                print(
                    "ECOA__return_status " + mname + "_container__" + op.get_name()
                    + "__publish_write_access(" + mname + "__context* context, " + mname
                    + "_container__" + op.get_name() + "_handle* data_handle)",
                    file=fd)
                print("{\n" + default_generated_comment, file=fd)
                print("  ECOA__return_status return_status = ECOA__return_status_OK;", file=fd)
                print("  free(data_handle->data);", file=fd)
                print("  return return_status;", file=fd)
                print("}\n", file=fd)
                print("", file=fd)
            elif op.get_type() == 'DR' or op.get_type() == 'DRN':
                print(
                    "ECOA__return_status " + mname + "_container__" + op.get_name()
                    + "__get_read_access(" + mname + "__context* context, " + mname
                    + "_container__" + op.get_name() + "_handle* data_handle)",
                    file=fd)
                print("{\n" + default_generated_comment, file=fd)
                print("  ECOA__return_status return_status = ECOA__return_status_INVALID_HANDLE;",
                      file=fd)
                print("  return return_status;", file=fd)
                print("}\n", file=fd)
                print(
                    "ECOA__return_status " + mname + "_container__" + op.get_name()
                    + "__release_read_access(" + mname + "__context* context, " + mname
                    + "_container__" + op.get_name() + "_handle* data_handle)",
                    file=fd)
                print("{\n" + default_generated_comment, file=fd)
                print("  ECOA__return_status return_status = ECOA__return_status_INVALID_HANDLE;",
                      file=fd)
                print("  return return_status;", file=fd)
                print("}\n", file=fd)
                print("", file=fd)

        print("/* Properties API */", file=fd)
        for (key, prop) in mtype.get_properties().items():
            print(
                "void " + mname + "__get_" + prop.get_name() + "_value(" + mname
                + "__context* context, " + prop.get_type() + "* value)",
                file=fd)
            print("{\n" + default_generated_comment+"\n}\n", file=fd)
        print("", file=fd)

        print("/* Logging services API call specifications */", file=fd)
        print("void " + mname + "_container__log_trace(" + mname
              + "__context* context, const ECOA__log log)", file=fd)
        print("{\n" + default_generated_comment+"\n}\n", file=fd)
        print("void " + mname + "_container__log_debug(" + mname
              + "__context* context, const ECOA__log log)", file=fd)
        print("{\n" + default_generated_comment+"\n}\n", file=fd)
        print("void " + mname + "_container__log_info(" + mname
              + "__context* context, const ECOA__log log)", file=fd)
        print("{\n" + default_generated_comment+"\n}\n", file=fd)
        print("void " + mname + "_container__log_warning(" + mname
              + "__context* context, const ECOA__log log)", file=fd)
        print("{\n" + default_generated_comment+"\n}\n", file=fd)
        print("void " + mname + "_container__raise_error(" + mname
              + "__context* context, const ECOA__log log, const ECOA__error_code error_code)", file=fd)
        print("{\n" + default_generated_comment+"\n}\n", file=fd)
        print("void " + mname + "_container__raise_fatal_error(" + mname
              + "__context* context, const ECOA__log log, const ECOA__error_code error_code)",
              file=fd)
        print("{\n" + default_generated_comment+"\n}\n", file=fd)
        print("", file=fd)

        print("/* Recovery action service API call specification if the module is a Fault Handler */",
              file=fd)
        if mtype.is_fault_handler():
            print("/* Fault Handling API */", file=fd)
            print("", file=fd)
            print("void " + mname + "_container__recovery_action(", file=fd)
            print("    " + mname + "__context* context,", file=fd)
            print("    ECOA__recovery_action_type recovery_action, ECOA__asset_id asset_id, "
                  "ECOA__asset_type asset_type)",
                  file=fd)
            print("{\n" + default_generated_comment+"\n}\n", file=fd)
        print("", file=fd)

        print("/* Time Services API call specifications */", file=fd)
        print(
            "void " + mname + "_container__get_relative_local_time(" + mname
            + "__context* context, ECOA__hr_time *relative_local_time)",
            file=fd)
        print("{\n" + default_generated_comment+"\n}\n", file=fd)
        print(
            "ECOA__return_status " + mname + "_container__get_UTC_time(" + mname
            + "__context* context, ECOA__global_time *utc_time)",
            file=fd)
        print("{\n" + default_generated_comment, file=fd)
        print("  ECOA__return_status return_status = ECOA__return_status_OK;", file=fd)
        print("  return return_status;", file=fd)
        print("}\n", file=fd)
        print(
            "ECOA__return_status " + mname + "_container__get_absolute_system_time("
            + mname + "__context* context, ECOA__global_time *absolute_system_time)",
            file=fd)
        print("{\n" + default_generated_comment, file=fd)
        print("  ECOA__return_status return_status = ECOA__return_status_OK;", file=fd)
        print("  return return_status;", file=fd)
        print("}\n", file=fd)
        print(
            "void " + mname + "_container__get_relative_local_time_resolution(" + mname
            + "__context* context, ECOA__duration *relative_local_time_resolution)",
            file=fd)
        print("{\n" + default_generated_comment + "\n}\n", file=fd)
        print(
            "void " + mname + "_container__get_UTC_time_resolution(" + mname
            + "__context* context, ECOA__duration *utc_time_resolution)",
            file=fd)
        print("{\n" + default_generated_comment + "\n}\n", file=fd)
        print(
            "void " + mname + "_container__get_absolute_system_time_resolution("
            + mname + "__context* context, ECOA__duration *absolute_system_time_resolution)",
            file=fd)
        print("{\n" + default_generated_comment + "\n}\n", file=fd)
        print("", file=fd)

        fd.close()
