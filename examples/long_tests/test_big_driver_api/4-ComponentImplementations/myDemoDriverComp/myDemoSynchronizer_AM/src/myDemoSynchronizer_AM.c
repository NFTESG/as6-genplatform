/* Generated by PARSEC */
/* Module Implementation myDemoSynchronizer_AM */

#include "ECOA.h"
#include "myDemoSynchronizer_AM.h"

#include <apr_general.h>
#include <apr_thread_proc.h>

#include "lib_array.h"
#include "myDemoDriverComp_External_Interface.h"
#include "ldp_mod_container_util.h"

#include <stdlib.h>

#include <assert.h>

static apr_pool_t* pool;
static apr_threadattr_t* attr;
static apr_thread_t* thread;
static int kill_received=0;

#define SEQUENCE_SIZE 26
static char sequence[] = "abcdefghijklmnopqrstuvwxyz";

static void copy_array_to(char* dest, unsigned int dest_size, char* src, unsigned int src_size)
{
	unsigned int offset=0;
	do {
		unsigned int size_to_copy = (offset+src_size) < (dest_size) ? src_size : ((dest_size) - offset);
		memcpy(&dest[offset], src, size_to_copy);

		offset+=size_to_copy;
	} while ( offset < dest_size);
}

void sendMessage(int functionIndex, myDemoSynchronizer_AM__context* ctx) {
	switch(functionIndex) {
		case 0 : myDemoDriverComp__Message_extern_1k(ctx->user.array_1k);
		break;
		case 1 : myDemoDriverComp__Message_extern_4k(ctx->user.array_4k);
		break;
		case 2 : myDemoDriverComp__Message_extern_16k(ctx->user.array_16k);
		break;
		case 3 : myDemoDriverComp__Message_extern_64k(ctx->user.array_64k);
		break;
		case 4 : myDemoDriverComp__Message_extern_256k(ctx->user.array_256k);
		break;
		case 5 : myDemoDriverComp__Message_extern_10m(ctx->user.array_10m);
		break;
	}
}

static void* APR_THREAD_FUNC messageGenerator(apr_thread_t * thread, void *data) {
	myDemoSynchronizer_AM__context* ctx = (myDemoSynchronizer_AM__context*)data;

	for(int i=0; i<10; i++) {
		for(int functionIndex=0; functionIndex<6; functionIndex++) {
			sendMessage(functionIndex, ctx);
			apr_sleep(50000);
		}
	}

	return NULL;
}

/* Entry points for lifecycle operations */
void myDemoSynchronizer_AM__INITIALIZE__received(myDemoSynchronizer_AM__context* context)
{
	context->user.array_1k = malloc(sizeof(lib_array__array_1k));
  context->user.array_4k = malloc(sizeof(lib_array__array_4k));
  context->user.array_16k = malloc(sizeof(lib_array__array_16k));
  context->user.array_64k = malloc(sizeof(lib_array__array_64k));
  context->user.array_256k = malloc(sizeof(lib_array__array_256k));
  context->user.array_10m = malloc(sizeof(lib_array__array_10m));

  copy_array_to((char*)context->user.array_1k, sizeof(lib_array__array_1k), sequence, SEQUENCE_SIZE);
  copy_array_to((char*)context->user.array_4k, sizeof(lib_array__array_4k), sequence, SEQUENCE_SIZE);
  copy_array_to((char*)context->user.array_16k, sizeof(lib_array__array_16k), sequence, SEQUENCE_SIZE);
  copy_array_to((char*)context->user.array_64k, sizeof(lib_array__array_64k), sequence, SEQUENCE_SIZE);
  copy_array_to((char*)context->user.array_256k, sizeof(lib_array__array_256k), sequence, SEQUENCE_SIZE);
  copy_array_to((char*)context->user.array_10m, sizeof(lib_array__array_10m), sequence, SEQUENCE_SIZE);
}

void myDemoSynchronizer_AM__START__received(myDemoSynchronizer_AM__context* context)
{
	apr_sleep(20000);
  apr_pool_create(&pool, NULL);
  apr_status_t rv;
  rv = apr_threadattr_create (&attr, pool);
  assert(rv == APR_SUCCESS);

  if ((rv=apr_thread_create(&thread, attr, messageGenerator, (void*)context, pool)) != APR_SUCCESS) {
    assert(rv == APR_SUCCESS);
  }
}

void myDemoSynchronizer_AM__STOP__received(myDemoSynchronizer_AM__context* context)
{
  /* @TODO TODO - To be implemented */
}

void myDemoSynchronizer_AM__SHUTDOWN__received(myDemoSynchronizer_AM__context* context)
{
	apr_status_t ret;
	apr_thread_join(&ret, thread);

	free(context->user.array_1k);context->user.array_1k = NULL;
	free(context->user.array_4k);context->user.array_4k = NULL;
	free(context->user.array_16k);context->user.array_16k = NULL;
	free(context->user.array_64k);context->user.array_64k = NULL;
	free(context->user.array_256k);context->user.array_256k = NULL;
	free(context->user.array_10m);context->user.array_10m = NULL;

	apr_pool_destroy(pool);
}

void myDemoSynchronizer_AM__Finish_received__received(myDemoSynchronizer_AM__context* context)
{
	kill_received++;
	if (kill_received==2)
  	ldp_kill_platform((ldp_module_context*)context->platform_hook);
}
