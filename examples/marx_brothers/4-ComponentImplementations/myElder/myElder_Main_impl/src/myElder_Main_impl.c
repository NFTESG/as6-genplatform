/**
* Copyright (c) 2023 Dassault Aviation
*
* SPDX-License-Identifier: MIT
*
* Generated by : LDP 1.0.0    
*                date: 2022-04-01 10:48:02.047975    
*/


/* Module Implementation myElder_Main_impl */

#include "ECOA.h"
#include "myElder_Main_impl.h"

#include "ECOA.h"
#include "libmarx.h"


#include <stdlib.h>

#include <string.h>
#include <stdio.h>
#include <stdarg.h>


#define MTRACE    0
#define MDEBUG    1
#define MINFO     2
#define MWARNING  3
#define MERROR    4
#define MFATAL    5

int myElder_Main_impl__fprintf (FILE * stream, const char *msg, ...);
#define GREATEST_FPRINTF myElder_Main_impl__fprintf

#include <greatest.h>

/* Add definitions that need to be in the test runner's main file. */
GREATEST_MAIN_DEFS ();

static myElder_Main_impl__context *greatest_ecoa_context;



int
myElder_Main_impl__log (myElder_Main_impl__context * context, int level, const char *msg, ...)
{
  ECOA__log log;
  va_list argp;

  va_start (argp, msg);
  vsnprintf ((char *) &log.data, ECOA__LOG_MAXSIZE, msg, argp);
  va_end (argp);
  log.current_size = strnlen ((char *) &log.data, ECOA__LOG_MAXSIZE);
  switch (level)
    {
    case MTRACE:
      myElder_Main_impl_container__log_trace (context, log);
      break;
    case MDEBUG:
      myElder_Main_impl_container__log_debug (context, log);
      break;
    case MINFO:
      myElder_Main_impl_container__log_info (context, log);
      break;
    case MWARNING:
      myElder_Main_impl_container__log_warning (context, log);
      break;
    default:
      myElder_Main_impl_container__log_trace (context, log);
    }
  return log.current_size;
}

int
myElder_Main_impl__fprintf (FILE * stream, const char *msg, ...)
{
  int ret;

  (void) stream;

  /* Declare a va_list type variable */
  va_list args;

  /* Initialise the va_list variable with the ... after msg */

  va_start (args, msg);

  /* Forward the '...' to log */

  ret = myElder_Main_impl__log (greatest_ecoa_context, MTRACE, msg, args);

  /* Clean up the va_list */
  va_end (args);

  return ret;
}



void
myElder_Main_impl__raise_error (myElder_Main_impl__context * context, int level, char *msg, ...)
{
  ECOA__log log;
  va_list argp;

  va_start (argp, msg);
  vsnprintf ((char *) &log.data, ECOA__LOG_MAXSIZE, msg, argp);
  va_end (argp);
  log.current_size = strnlen ((char *) &log.data, ECOA__LOG_MAXSIZE);
  switch (level)
    {
    case MERROR:
      myElder_Main_impl_container__raise_error (context, log, 0);
      break;
    case MFATAL:
      myElder_Main_impl_container__raise_fatal_error (context, log, 0);
      break;
    default:
      myElder_Main_impl_container__raise_error (context, log, 0);
    }
}


void
myElder_Main_impl__pinfo (myElder_Main_impl__context * context)
{
  ECOA__return_status status;
  ECOA__uint32 new_position;
  ECOA__int32 offset;
  ECOA__seek_whence_type whence;
  ECOA__byte *memory_address;
  ECOA__uint32 in_size;
  ECOA__uint32 out_size;

  offset = 0;
  whence = ECOA__seek_whence_type_SEEK_SET;
  in_size = 10;
  memory_address = malloc (in_size);

  status = myElder_Main_impl_container__seek_myPrivatePinfo (context, offset, whence, &new_position);
  if (status != ECOA__return_status_OK)
    {
      myElder_Main_impl__log (context, MWARNING, "seek myPrivateInfo failed (%d)", status);
    }

  status = myElder_Main_impl_container__read_myPrivatePinfo (context, memory_address, in_size, &out_size);
  if (status != ECOA__return_status_OK)
    {
      myElder_Main_impl__log (context, MWARNING, "read myPrivateInfo failed (%d)", status);
    }

  status = myElder_Main_impl_container__seek_myPublicPinfo_1 (context, offset, whence, &new_position);
  if (status != ECOA__return_status_OK)
    {
      myElder_Main_impl__log (context, MWARNING, "seek myPublicInfo 1 failed (%d)", status);
    }

  status = myElder_Main_impl_container__read_myPublicPinfo_1 (context, memory_address, in_size, &out_size);
  if (status != ECOA__return_status_OK)
    {
      myElder_Main_impl__log (context, MWARNING, "read myPublicInfo 1 failed (%d)", status);
    }

  status = myElder_Main_impl_container__seek_myPublicPinfo_2 (context, offset, whence, &new_position);
  if (status != ECOA__return_status_OK)
    {
      myElder_Main_impl__log (context, MWARNING, "seek myPublicInfo 2 failed (%d)", status);
    }

  status = myElder_Main_impl_container__read_myPublicPinfo_2 (context, memory_address, in_size, &out_size);
  if (status != ECOA__return_status_OK)
    {
      myElder_Main_impl__log (context, MWARNING, "read myPublicInfo 2 failed (%d)", status);
    }

  free (memory_address);
}


void
myElder_Main_impl__logs (myElder_Main_impl__context * context)
{
  ECOA__log log = {.data="Elder logs", .current_size=10};

  myElder_Main_impl_container__log_trace (context, log);
  myElder_Main_impl_container__log_debug (context, log);
  myElder_Main_impl_container__log_info (context, log);
  myElder_Main_impl_container__log_warning (context, log);
  myElder_Main_impl_container__raise_error (context, log, 0);
  /*
   * myElder_Main_impl_container__raise_fatal_error(context, log, 0); 
   */
}

void
myElder_Main_impl__time (myElder_Main_impl__context * context)
{
  ECOA__hr_time relative_local_time;
  ECOA__global_time utc_time;
  ECOA__global_time absolute_system_time;
  ECOA__duration relative_local_time_resolution;
  ECOA__duration utc_time_resolution;
  ECOA__duration absolute_system_time_resolution;
  ECOA__return_status status;

  myElder_Main_impl_container__get_relative_local_time (context, &relative_local_time);

  status = myElder_Main_impl_container__get_UTC_time (context, &utc_time);
  if (status != ECOA__return_status_OK)
    {
      myElder_Main_impl__log (context, MWARNING, "get UTC time failed (%d)", status);
    }

  status = myElder_Main_impl_container__get_absolute_system_time (context, &absolute_system_time);
  if (status != ECOA__return_status_OK)
    {
      myElder_Main_impl__log (context, MWARNING, "get absolute system time failed (%d)", status);
    }

  myElder_Main_impl_container__get_relative_local_time_resolution (context, &relative_local_time_resolution);
  myElder_Main_impl_container__get_UTC_time_resolution (context, &utc_time_resolution);
  myElder_Main_impl_container__get_absolute_system_time_resolution (context, &absolute_system_time_resolution);
}

/*
 * Entry points for lifecycle operations 
 */
void
myElder_Main_impl__INITIALIZE__received (myElder_Main_impl__context * context)
{

  myElder_Main_impl_container__get_ID_value (context, &context->user.id);

  myElder_Main_impl__log (context, MTRACE, "ID = %d", context->user.id);

  context->user.notification_number = 0;
  context->user.counter = 0;

  context->user.data.F_ID = context->user.id;
  context->user.data.F_Counter = 0;
  context->user.data.F_Angle = 0.5;

  context->user.data.F_Vector.x = 0xA0;
  context->user.data.F_Vector.y = 0xB0;
  context->user.data.F_Vector.z = 0xC0;

  for (int i = 0; i < libmarx__T_Array_MAXSIZE; i++)
    {
      context->user.data.F_Array.data[i] = i;
    }
  context->user.data.F_Array.current_size = libmarx__T_Array_MAXSIZE;

  for (int i = 0; i < libmarx__T_FixedArray_MAXSIZE; i++)
    {
      context->user.data.F_FixedArray[i].x = i * 2;
      context->user.data.F_FixedArray[i].y = i * 2 + 1;
      context->user.data.F_FixedArray[i].z = i * 2 + 2;
    }

  context->user.pinfo_test_flag = ECOA__FALSE;
  context->user.log_test_flag = ECOA__FALSE;
  context->user.time_test_flag = ECOA__FALSE;

  greatest_ecoa_context = context;

}

void
myElder_Main_impl__START__received (myElder_Main_impl__context * context)
{

  if (context->user.pinfo_test_flag == ECOA__FALSE)
    {
      myElder_Main_impl__pinfo (context);
      context->user.pinfo_test_flag = ECOA__TRUE;
    }

  if (context->user.log_test_flag == ECOA__FALSE)
    {
      myElder_Main_impl__logs (context);
      context->user.log_test_flag = ECOA__TRUE;
    }

  if (context->user.time_test_flag == ECOA__FALSE)
    {
      myElder_Main_impl__time (context);
      context->user.time_test_flag = ECOA__TRUE;
    }

}

void
myElder_Main_impl__STOP__received (myElder_Main_impl__context * context)
{
  /*
   * @TODO TODO - To be implemented 
   */
}

void
myElder_Main_impl__SHUTDOWN__received (myElder_Main_impl__context * context)
{
  /*
   * @TODO TODO - To be implemented 
   */
}


void
myElder_Main_impl__activate__received (myElder_Main_impl__context * context)
{
  ECOA__return_status return_status;
  myElder_Main_impl_container__information_handle data_handle;

  myElder_Main_impl_container__command__send (context, &context->user.data);


  return_status = myElder_Main_impl_container__information__get_read_access (context, &data_handle);
  if (return_status == ECOA__return_status_OK)
    {
      /*
       * @TODO - read actual value 
       */
      return_status = myElder_Main_impl_container__information__release_read_access (context, &data_handle);
      if (return_status != ECOA__return_status_OK)
        {
          myElder_Main_impl__log (context, MWARNING, "release read access failed (%d)", return_status);
        }
    }
  else
    {
      myElder_Main_impl__log (context, MWARNING, "get read access (%d)", return_status);
    }

  /*
   * @TODO - Call myElder_Main_impl__raise at a given time in future 
   */


}

/* TODO */
TEST
data_access_test_1 ()
{

  ASSERT_EQ (ECOA__return_status_OK, ECOA__return_status_OK);

  PASS ();
}

TEST
data_access_test_2 ()
{

  ASSERT_EQ (ECOA__return_status_OK, ECOA__return_status_OK);

  PASS ();
}


/* Suites can group multiple tests with common setup. */
SUITE (marx_suite)
{
  RUN_TEST (data_access_test_1);
  RUN_TEST (data_access_test_2);
}


int
tests (myElder_Main_impl__context * context)
{
  GREATEST_INIT ();             /* init. greatest internals */

  greatest_set_verbosity (100);

  RUN_SUITE (marx_suite);

  GREATEST_PRINT_REPORT ();     /* display results */

  return greatest_all_passed ();
}


void
myElder_Main_impl__notification__received (myElder_Main_impl__context * context, const libmarx__T_Data * param)
{
  ECOA__return_status status;
  libmarx__T_Data output;

  context->user.notification_number++;
  if (param->F_ID == context->user.id && param->F_Counter > context->user.counter)
    {
      context->user.data = *param;
      context->user.counter = param->F_Counter;
      myElder_Main_impl__log (context, MTRACE, "notif counter = %d notif number = %d", context->user.counter,
                              context->user.notification_number);
    }


  if (context->user.id == 42)
    {
      status = myElder_Main_impl_container__transaction_1__request_sync (context, &context->user.data, &output);
      if (status != ECOA__return_status_OK)
        {
          myElder_Main_impl__log (context, MTRACE, "transaction 1 failed (%d)", status);
        }
    }
  else
    {
      status = myElder_Main_impl_container__transaction_2__request_sync (context, &context->user.data, &output);
      if (status != ECOA__return_status_OK)
        {
          myElder_Main_impl__log (context, MTRACE, "transaction 2 failed (%d)", status);
        }
    }
}

void
myElder_Main_impl__test_report__received (myElder_Main_impl__context * context, const libmarx__T_TR_Set * param)
{
}
