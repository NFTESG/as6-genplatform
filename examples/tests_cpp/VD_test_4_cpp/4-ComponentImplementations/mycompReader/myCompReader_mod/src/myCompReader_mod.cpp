/* Generated by PARSEC */
/* Module Implementation for myCompReader_mod
Done by Florian using Jinja */

#include "ECOA.hpp"
#include "myCompReader_mod.hpp"

#include "VD_lib.hpp"
#include <assert.h>
#include "stdio.h"

namespace myCompReader_mod
{

/* Entry points for lifecycle operations */
void Module::INITIALIZE__received(){
	user.vector0_read = 0;
 	user.vector1_read = 0;
}
void Module::START__received(){
}
void Module::STOP__received(){
/* @TODO TODO - To be implemented */
}
void Module::SHUTDOWN__received(){
/* @TODO TODO - To be implemented */
}



void Module::read_vector1__updated()
{
	read_vector1_handle data_handle;
	ECOA::return_status ret = container->read_vector1__get_read_access(data_handle);
	assert(ret == ECOA::return_status::OK);

	if (data_handle.data->nb_x == 12 && data_handle.data->nb_y == 3141516){
		user.vector1_read += 1;
		if (user.vector1_read == 2 && user.vector0_read == 2){
			container->finish__send();
		}
	}

	ret = container->read_vector1__release_read_access(data_handle);

}




void Module::read_vector0__updated()
{
	read_vector0_handle data_handle;
	ECOA::return_status ret = container->read_vector0__get_read_access(data_handle);
	assert(ret == ECOA::return_status::OK);

	if (data_handle.data->nb_x == 22 && data_handle.data->nb_y == 3141516){
		user.vector0_read += 1;
		if (user.vector1_read = 2 && user.vector0_read == 2){
			container->finish__send();
		}
	}

	ret = container->read_vector0__release_read_access(data_handle);
}

/* Fault Handling API , linked to another namespace (fault_handler_impl_name) */

extern "C" {

	Module* myCompReader_mod__new_instance()
	{
		return new Module();
	}
}

} /* namespace myCompReader_mod */
