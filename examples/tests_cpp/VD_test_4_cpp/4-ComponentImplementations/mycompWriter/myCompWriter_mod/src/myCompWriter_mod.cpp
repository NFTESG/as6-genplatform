/* Generated by PARSEC */
/* Module Implementation for myCompWriter_mod
Done by Florian using Jinja */

#include "ECOA.hpp"
#include "myCompWriter_mod.hpp"


#include "VD_lib.hpp"
#include <assert.h>
#include <stdio.h>
#include <unistd.h>

namespace myCompWriter_mod
{

/* Entry points for lifecycle operations */
void Module::INITIALIZE__received(){
/* @TODO TODO - To be implemented */
}
void Module::START__received(){
	sleep(1);
	write_vector1_handle data_handle1;
    ECOA::return_status ret = container->write_vector1__get_write_access(data_handle1);
    assert(ret.value == ECOA::return_status::DATA_NOT_INITIALIZED);
    data_handle1.data->nb_x = 12;
    data_handle1.data->nb_y = 3141516;

	ret = container->write_vector1__publish_write_access(data_handle1);
    assert(ret.value == ECOA::return_status::OK);



    // second read
	write_vector1_handle data_handle12;
	ret = container->write_vector1__get_write_access(data_handle12);
    assert(ret.value == ECOA::return_status::OK);
    assert(data_handle12.data->nb_x == 12);



	ret = container->write_vector1__publish_write_access(data_handle12);
    assert(ret.value == ECOA::return_status::OK);
	write_vector0_handle data_handle2;
    ret = container->write_vector0__get_write_access(data_handle2);
    assert(ret.value == ECOA::return_status::DATA_NOT_INITIALIZED);
    data_handle2.data->nb_x = 22;
    data_handle2.data->nb_y = 3141516;

	ret = container->write_vector0__publish_write_access(data_handle2);
    assert(ret.value == ECOA::return_status::OK);

    // second read
	write_vector0_handle data_handle22;
	ret = container->write_vector0__get_write_access(data_handle22);
    assert(ret.value == ECOA::return_status::OK);
    assert(data_handle22.data->nb_x == 22);

	ret = container->write_vector0__publish_write_access(data_handle22);
    assert(ret.value == ECOA::return_status::OK);

}
void Module::STOP__received(){
/* @TODO TODO - To be implemented */
}
void Module::SHUTDOWN__received(){
/* @TODO TODO - To be implemented */
}


/* Fault Handling API , linked to another namespace (fault_handler_impl_name) */

extern "C" {

	Module* myCompWriter_mod__new_instance()
	{
		return new Module();
	}
}

} /* namespace myCompWriter_mod */
