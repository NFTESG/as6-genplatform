/* Generated by PARSEC */
/* Module Implementation for myDemoEmitter_AM*/

#include <assert.h>


#include "ECOA.hpp"
#include "lib_module.hpp"
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <unistd.h>
#include "myDemoEmitter_AM.hpp"

namespace myDemoEmitter_AM
{
static void print_log(Container* container, const char *format, ...){
    va_list vl;
    ECOA::log log;

    va_start(vl, format);
    vsnprintf(log.data, ECOA::LOG_MAXSIZE, format, vl);
    va_end( vl);

  container->log_trace(log);
}
/* Entry points for lifecycle operations */

void Module::INITIALIZE__received(){
	/* @TODO TODO - To be implemented */
}

void Module::START__received(){

  sleep(1);
	printf("##############\n");
  sleep(1);
  ECOA::uint32 ID;
  ECOA::return_status ret;
  ECOA::uint32 module_implementation_identifier;

  container->get_module_identifier_value( module_implementation_identifier);

  container->Event_Sent__send( module_implementation_identifier);
  print_log(container, "'container->Event_Sent__send' [SENT] with identifier : [%d]", module_implementation_identifier);

  // data written2
  write_data2_handle handle2;
  ret = container->write_data2__get_write_access( handle2);
  print_log(container, "'container->write_data2__publish_write_access' [SENT] with identifier : [%d]", module_implementation_identifier);
  assert(ret == ECOA::return_status::OK || ret == ECOA::return_status::DATA_NOT_INITIALIZED);
  ((unsigned char*)handle2.data)[module_implementation_identifier]=module_implementation_identifier+10;
  ret=container->write_data2__publish_write_access( handle2);
  assert(ret == ECOA::return_status::OK);

  // Sync RR
  ret = container->Request_Sync_Sent__request_sync( module_implementation_identifier);
  print_log(container, "'container->Request_Sync_Sent__request_sync' [SENT] with identifier : [%d]", module_implementation_identifier);
  if (module_implementation_identifier == 0x01){
    assert(ret == ECOA::return_status::OK);
  }else{
    assert(ret == ECOA::return_status::NO_RESPONSE);
  }

  // Async RR
  ret = container->Request_Async_Sent__request_async( ID, module_implementation_identifier);
  print_log(container, "'container->Request_Async_Sent__request_async' [SENT] with identifier : [%d]", module_implementation_identifier);
  if (module_implementation_identifier == 0x01){
    assert(ret == ECOA::return_status::OK);
  }else{
    assert(ret == ECOA::return_status::NO_RESPONSE);
  }

  // data write
  write_data_handle handle;
  ret = container->write_data__get_write_access( handle);
  if (ret != ECOA::return_status::DATA_NOT_INITIALIZED){
    printf("FAILED DW in module %i (%i)\n", module_implementation_identifier, ret);
  }else{
    assert(ret == ECOA::return_status::DATA_NOT_INITIALIZED);
    memcpy(handle.data, &module_implementation_identifier, sizeof(ECOA::uint32));
    print_log(container, "'container->write_data__publish_write_access' [SENT] with identifier : [%d]", module_implementation_identifier);
    ret=container->write_data__publish_write_access( handle);
    assert(ret == ECOA::return_status::OK);
  }

  ret = container->write_data2__get_write_access( handle2);
  printf("[%i] %i %i %i \n", module_implementation_identifier,
                            ((unsigned char*)handle2.data)[0],
                            ((unsigned char*)handle2.data)[1],
                            ((unsigned char*)handle2.data)[2]);
  ret=container->write_data2__cancel_write_access( handle2);

  if (module_implementation_identifier != 0x01){

    container->Finish_Sent__send();
  }
}

void Module::STOP__received(){
	/* @TODO TODO - To be implemented */
}

void Module::SHUTDOWN__received(){
	/* @TODO TODO - To be implemented */
}

void Module::Request_Async_Sent__response_received(const ECOA::uint32 ID, const ECOA::return_status status){
  ECOA::uint32 module_implementation_identifier;
  container->get_module_identifier_value( module_implementation_identifier);
  assert(module_implementation_identifier == 0x01);
  assert(status == ECOA::return_status::OK);
  container->Finish_Sent__send();
}

/* Fault Handling API , linked to another namespace (fault_handler_impl_name) */

extern "C" {

	Module* myDemoEmitter_AM__new_instance()
	{
		return new Module();
	}
}

} /* namespace myDemoEmitter_AM */
