/* Generated by PARSEC */
/* Module Implementation myWriter_mod */

#include "ECOA.h"
#include "myWriter_mod.h"

#include "ECOA.h"
#include "VD_lib.h"
#include "assert.h"

#include <stdarg.h>
#include <string.h>

static void print_log(myWriter_mod__context* context, const char *format, ...){
	va_list vl;
	ECOA__log log;
	va_start(vl, format);
	vsnprintf(log.data, ECOA__LOG_MAXSIZE, format, vl);
	va_end( vl);

	myWriter_mod_container__log_trace(context, log);
}

/* Entry points for lifecycle operations */
void myWriter_mod__INITIALIZE__received(myWriter_mod__context* context)
{
  /* @TODO TODO - To be implemented */
}

void myWriter_mod__START__received(myWriter_mod__context* context)
{
  ECOA__uint32 mod_id;
  myWriter_mod_container__get_mod_id_value(context, &mod_id);
  VD_lib__vector_data new_vector={-33,33};
  if(mod_id == 1){
    myWriter_mod_container__write_vector_handle handle;
    ECOA__return_status ret = myWriter_mod_container__write_vector__get_write_access(context, &handle);
    assert(ret == ECOA__return_status_DATA_NOT_INITIALIZED);
    print_log(context,"first write");
    memcpy(handle.data, &new_vector,sizeof(VD_lib__vector_data) );
    ret=myWriter_mod_container__write_vector__publish_write_access(context, &handle);
    assert(ret == ECOA__return_status_OK);

    context->user.nb_write=1;
  }
  memcpy(&context->user.old_vector, &new_vector,sizeof(VD_lib__vector_data));

}

void myWriter_mod__TriggerEvent__received(myWriter_mod__context* context){

  ECOA__uint32 mod_id;
  myWriter_mod_container__get_mod_id_value(context, &mod_id);

  VD_lib__vector_data new_vector={0,0};
  myWriter_mod_container__write_vector_handle handle;

  ECOA__return_status ret = myWriter_mod_container__write_vector__get_write_access(context, &handle);

  if(ret == ECOA__return_status_DATA_NOT_INITIALIZED){
    // first write is made by the module with ID=1
    assert(myWriter_mod_container__write_vector__cancel_write_access(context, &handle) == ECOA__return_status_OK);

  }else if(ret == ECOA__return_status_OK){
    // write

    memcpy(&new_vector,handle.data,sizeof(VD_lib__vector_data));
    assert( new_vector.nb_y == -new_vector.nb_x );

    if(new_vector.nb_x == new_vector.nb_y && new_vector.nb_x == 0){
      assert(myWriter_mod_container__write_vector__cancel_write_access(context, &handle) == ECOA__return_status_OK);
      print_log(context,"writer finish %i", mod_id);
      return;
    }

    new_vector.nb_x++;
    new_vector.nb_y--;

    memcpy(handle.data, &new_vector,sizeof(VD_lib__vector_data) );
    memcpy(&context->user.old_vector, &new_vector,sizeof(VD_lib__vector_data) );

    ret=myWriter_mod_container__write_vector__publish_write_access(context, &handle);
    assert(ret == ECOA__return_status_OK);

  }else{
    print_log(context,"writer finish  %i: error = %i", mod_id, ret);
    assert(0);
  }
}

void myWriter_mod__STOP__received(myWriter_mod__context* context)
{
  /* @TODO TODO - To be implemented */
}

void myWriter_mod__SHUTDOWN__received(myWriter_mod__context* context)
{
  /* @TODO TODO - To be implemented */
}

