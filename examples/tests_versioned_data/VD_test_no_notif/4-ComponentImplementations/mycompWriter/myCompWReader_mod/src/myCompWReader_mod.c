/* Generated by PARSEC */
/* Module Implementation myCompWReader_mod */

#include "ECOA.h"
#include "myCompWReader_mod.h"


#include <assert.h>
#include <string.h>
#include <unistd.h>
#include <stdio.h>

#include "VD_lib.h"

/* Entry points for lifecycle operations */
#include <stdarg.h>
static void print_log(myCompWReader_mod__context* context, const char *format, ...){
va_list vl;
ECOA__log log;
va_start(vl, format);
vsnprintf(log.data, ECOA__LOG_MAXSIZE, format, vl);
va_end( vl);

myCompWReader_mod_container__log_trace(context, log);
}

void myCompWReader_mod__INITIALIZE__received(myCompWReader_mod__context* context)
{
  /* @TODO TODO - To be implemented */
}

void myCompWReader_mod__REINITIALIZE__received(myCompWReader_mod__context* context)
{
  /* @TODO TODO - To be implemented */
}

void myCompWReader_mod__START__received(myCompWReader_mod__context* context)
{
  /* @TODO TODO - To be implemented */
}

void myCompWReader_mod__STOP__received(myCompWReader_mod__context* context)
{
  /* @TODO TODO - To be implemented */
}

void myCompWReader_mod__SHUTDOWN__received(myCompWReader_mod__context* context)
{
  /* @TODO TODO - To be implemented */
}

void myCompWReader_mod__trigger__received(myCompWReader_mod__context* context){
	VD_lib__vector_data new_vector={0,0};
	myCompWReader_mod_container__read_vector_handle data_type;
	ECOA__return_status ret = myCompWReader_mod_container__read_vector__get_read_access(context, &data_type);
	assert(ret == ECOA__return_status_OK);

	memcpy(&new_vector,data_type.data,sizeof(VD_lib__vector_data) );

	print_log(context,"== DATA updated %i %i\n",new_vector.nb_x, new_vector.nb_y);
	if(new_vector.nb_x == new_vector.nb_y){
		print_log(context,"reader finish");
		myCompWReader_mod_container__finish__send(context);
		assert(1);
	}
	ret = myCompWReader_mod_container__read_vector__release_read_access(context, &data_type);
	assert(ret == ECOA__return_status_OK);
}

